"""
This module contains functionality that is used when it comes to processing and extracting
information from the `test_manifest.json` file that gets generated by several dbt commands.

Facts:
- Snapshots are never an upstream dependency of any task
- Snapshots on seeds (if possible?) are not handled
- Models may have tests
- Snapshots may have tests
- Seeds may have tests
- A test node on dbt manifest has only a single model in `depends_on` that corresponds to the
    model node name to which the test belongs to

Strategy:
    - Iterate all over tasks and create tasks for each model, test, seed and snapshot found
        in the manifest file
    - Extract the dependencies between the tasks created
"""
import json
import logging
import os
from typing import Set


from ..exceptions import ManifestNotFound, ManifestDataNotFound, InvalidDbtCommand
from .tasks import Task, TaskList
from .model import DbtResourceType, Manifest, Node


class TaskLoader:

    def __init__(self, manifest_path: str):
        self.tasks = TaskList()
        self.path = os.path.abspath(manifest_path)

        self.manifest = self.load_manifest()
        self.test_deps = self.load_test_dependencies()

    def load_test_dependencies(self) -> Set[str]:
        """
        Loads all the dependencies found in test nodes within manifest file.
        This set of dependencies is then used to determine whether a test task should be created
        for model/seed/snapshot tasks inferred.
        """
        entities_with_tests = set()

        for dbt_node_name, node in self.manifest.nodes.items():
            if node.resource_type == DbtResourceType.test:
                entities_with_tests.update(node.depends_on.nodes)

        logging.info(
            f'Found {len(entities_with_tests)} models, snapshots or seeds with dbt tests.'
        )

        return entities_with_tests

    def load_manifest(self) -> Manifest:
        """
        Loads the test_manifest.json file created by dbt
        """
        logging.info(f'Loading {self.path} file')
        if not os.path.isfile(self.path):
            raise ManifestNotFound(
                f'Manifest file was not found in {self.path}. '
                f'Make sure that you are running dbt-airflow from your dbt project directory '
                f'and that the project is compiled (hint: `dbt compile`).'
            )

        with open(self.path, 'r') as f:
            data = json.load(f)

        manifest = Manifest(**data)
        logging.info(f'{self.path} file was loaded successfully.')
        logging.info(f'Found {manifest.get_statistics()}')

        return manifest

    def create_tasks(self) -> TaskList:
        """
        Returns a TaskList instance consisting of the tasks created out of the
        input dbt manifest JSON file.
        """
        logging.info('Creating tasks from manifest data')
        if not self.manifest:
            raise ManifestDataNotFound('No data was found.')

        for dbt_node_name, node in self.manifest.nodes.items():
            if node.resource_type in [
                DbtResourceType.model, DbtResourceType.seed, DbtResourceType.snapshot
            ]:
                self._create_task(dbt_node_name, node)

        self._fix_dependencies()

        logging.info(f'Created a TaskList of: {self.tasks.get_statistics()}')
        logging.warning(
            'The number of tests created could be less of the original number of tests reported '
            'in manifest file. This is due to the fact that the resulting Airflow DAG will only '
            'create a single test task, to execute all the tests for a particular model, '
            'snapshot or seed.'
        )
        return self.tasks

    def _create_task(self, node_name: str, node: Node) -> None:
        """
        Create a task for a model(run), snapshot or seed. If the model also has tests, create
        an additional test node
        """
        task = Task.create_task_from_manifest_node(node_name=node_name, node=node)
        self.tasks.append(task)

        if task.dbt_node_name in self.test_deps:
            test_task = Task(
                model_name=task.model_name,
                dbt_command=DbtResourceType.test,
                dbt_node_name='',
                upstream_tasks={task.name},
                task_group=task.task_group
            )
            self.tasks.append(test_task)

    def _fix_dependencies(self) -> None:
        """
        This method is supposed to fix the dependencies between the created tasks.

        For every qualifying model/seed/snapshot a test task was also created. Therefore, we need
        to adjust the dependencies of the models so that the newly created test tasks are placed
        in the correct position within the dependency graph.

        Note:
            - The upstream dependencies of test tasks are already correct, since we created them
                and they were not read by the manifest file
        """
        for task in self.tasks:
            if task.dbt_command == DbtResourceType.test:
                self._update_upstream_dependencies(task)

    def _update_upstream_dependencies(self, test_task: Task) -> None:
        """

        """
        if test_task.dbt_command != DbtResourceType.test:
            raise InvalidDbtCommand(
                f'Task {test_task.name} with dbt command {test_task.dbt_command} is invalid.'
            )

        # First we need to find the corresponding task that is responsible for running the model
        model_run_task = self.tasks.find_task_by_name(list(test_task.upstream_tasks)[0])

        for task in self.tasks:
            if task.dbt_command != DbtResourceType.test \
                    and model_run_task.name in task.upstream_tasks:
                # Remove model run dependency
                task.upstream_tasks.remove(model_run_task.name)

                # Add model test dependency
                task.upstream_tasks.add(test_task.name)

